/* automatically generated by rust-bindgen */

#![allow(non_camel_case_types)]
#![allow(intra_doc_link_resolution_failure)]

pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type esp_err_t = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coex_adapter_funcs_t {
    pub _version: i32,
    pub _spin_lock_create: ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>,
    pub _spin_lock_delete: ::core::option::Option<unsafe extern "C" fn(lock: *mut cty::c_void)>,
    pub _int_disable: ::core::option::Option<unsafe extern "C" fn(mux: *mut cty::c_void) -> u32>,
    pub _int_enable: ::core::option::Option<unsafe extern "C" fn(mux: *mut cty::c_void, tmp: u32)>,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create:
        ::core::option::Option<unsafe extern "C" fn(max: u32, init: u32) -> *mut cty::c_void>,
    pub _semphr_delete: ::core::option::Option<unsafe extern "C" fn(semphr: *mut cty::c_void)>,
    pub _semphr_take_from_isr: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut cty::c_void, hptw: *mut cty::c_void) -> i32,
    >,
    pub _semphr_give_from_isr: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut cty::c_void, hptw: *mut cty::c_void) -> i32,
    >,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut cty::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give: ::core::option::Option<unsafe extern "C" fn(semphr: *mut cty::c_void) -> i32>,
    pub _is_in_isr: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut cty::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut cty::c_void)>,
    pub _timer_disarm: ::core::option::Option<unsafe extern "C" fn(timer: *mut cty::c_void)>,
    pub _timer_done: ::core::option::Option<unsafe extern "C" fn(ptimer: *mut cty::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut cty::c_void,
            pfunction: *mut cty::c_void,
            parg: *mut cty::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut cty::c_void, us: u32, repeat: bool),
    >,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _magic: i32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum coex_prefer_t {
    COEX_PREFER_WIFI = 0,
    COEX_PREFER_BT = 1,
    COEX_PREFER_BALANCE = 2,
    COEX_PREFER_NUM = 3,
}
pub type coex_func_cb_t =
    ::core::option::Option<unsafe extern "C" fn(event: u32, sched_cnt: cty::c_int)>;
extern "C" {
    #[doc = " @brief Pre-Init software coexist"]
    #[doc = "        extern function for internal use."]
    #[doc = ""]
    #[doc = " @return Init ok or failed."]
    pub fn coex_pre_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Init software coexist"]
    #[doc = "        extern function for internal use."]
    #[doc = ""]
    #[doc = " @return Init ok or failed."]
    pub fn coex_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-init software coexist"]
    #[doc = "        extern function for internal use."]
    pub fn coex_deinit();
}
extern "C" {
    #[doc = " @brief Pause software coexist"]
    #[doc = "        extern function for internal use."]
    pub fn coex_pause();
}
extern "C" {
    #[doc = " @brief Resume software coexist"]
    #[doc = "        extern function for internal use."]
    pub fn coex_resume();
}
extern "C" {
    #[doc = " @brief Get software coexist version string"]
    #[doc = "        extern function for internal use."]
    #[doc = " @return : version string"]
    pub fn coex_version_get() -> *const cty::c_char;
}
extern "C" {
    #[doc = " @brief Coexist performance preference set from libbt.a"]
    #[doc = "        extern function for internal use."]
    #[doc = ""]
    #[doc = "  @param prefer : the prefer enumeration value"]
    #[doc = "  @return : ESP_OK - success, other - failed"]
    pub fn coex_preference_set(prefer: coex_prefer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get software coexist status."]
    #[doc = " @return : software coexist status"]
    pub fn coex_status_get() -> u32;
}
extern "C" {
    #[doc = " @brief Set software coexist condition."]
    #[doc = " @return : software coexist condition"]
    pub fn coex_condition_set(type_: u32, dissatisfy: bool);
}
extern "C" {
    #[doc = " @brief WiFi requests coexistence."]
    #[doc = ""]
    #[doc = "  @param event : WiFi event"]
    #[doc = "  @param latency : WiFi will request coexistence after latency"]
    #[doc = "  @param duration : duration for WiFi to request coexistence"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_wifi_request(event: u32, latency: u32, duration: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief WiFi release coexistence."]
    #[doc = ""]
    #[doc = "  @param event : WiFi event"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_wifi_release(event: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Blue tooth requests coexistence."]
    #[doc = ""]
    #[doc = "  @param event : blue tooth event"]
    #[doc = "  @param latency : blue tooth will request coexistence after latency"]
    #[doc = "  @param duration : duration for blue tooth to request coexistence"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_bt_request(event: u32, latency: u32, duration: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Blue tooth release coexistence."]
    #[doc = ""]
    #[doc = "  @param event : blue tooth event"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_bt_release(event: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Register callback function for blue tooth."]
    #[doc = ""]
    #[doc = "  @param cb : callback function"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_register_bt_cb(cb: coex_func_cb_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Lock before reset base band."]
    #[doc = ""]
    #[doc = "  @return : lock value"]
    pub fn coex_bb_reset_lock() -> u32;
}
extern "C" {
    #[doc = " @brief Unlock after reset base band."]
    #[doc = ""]
    #[doc = "  @param restore : lock value"]
    pub fn coex_bb_reset_unlock(restore: u32);
}
extern "C" {
    #[doc = " @brief Register coexistence adapter functions."]
    #[doc = ""]
    #[doc = "  @param funcs : coexistence adapter functions"]
    #[doc = "  @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_adapter_register(funcs: *mut coex_adapter_funcs_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the coexistence adapter header files in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_coex_adapter_funcs_md5_check(md5: *const cty::c_char) -> esp_err_t;
}
